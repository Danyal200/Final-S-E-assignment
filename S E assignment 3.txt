                   SUMMARY
TOPIC:

 An Empirical Study of Method Chaining in Java

AUTHORS NAME:
Tomoki Nakamaru, Tomomasa Matsunaga, Tetsuro Yamazaki, Soramichi
Akiyama, and Shigeru Chiba. 2020.

 CONFERENCE NAME: 
 Mining Software Repositories (MSR'20),
An Empirical Study of Method Chaining
in Java. In 17th International Conference on Mining Software Repositories
(MSR ’20), October 5–6, 2020, Seoul, Republic of Korea. ACM, New York, NY,
USA, 10 pages.

                INTRODUCTION:

We present, to the best of our knowledge, the first quantitative study on the use of method chaining that is based on a large set of source code in the real world.
We empirically show the increasing use of method chaining in Java, which has been claimed without empirical evidence in preceding studies [20, 21, 26, 33, 34, 42, 43].
We present language features (or API design) that support method chaining but are not supported yet in Java. We statistically estimated how effective each feature/design would be.
Method chaining is promoted as a good practice that improves the readability of source code. By method chaining, redundant temporary variables and code repetitions are eliminated [8]; related method invocations are grouped into a single expression [34, 42];an expression becomes easy to read from left to right as naturallanguage texts [13, 14, 18, 42].
If you do everything in a single statement then that is compact, but it is less readable (harder to follow) most of the times than doing it in multiple statements.

                  RESEARCH METHODOLOGY:

To build our dataset, we collected 2,814 Java repositories on GitHub.
Those repositories are the ones that were listed at least once in the most-starred 1000 Java repositories on GitHub between Nov.
10th, 2019 and Dec. 21st, 2019. We collected them by monitoring the response of the GitHub API1
every day during that period.
Our dataset contains over three million Java files (approximately seven hundred million lines) in total.
The relative number of method chains has increased from 2010 to 2018 in almost all lengths.
 In our analyses, we use only the code that is newer than or in 2010. 2010 is the year in which the number of repositories exceeds 250 and
in which the number of files exceeds 105 for the first time. We adopt this criterion to avoid that the programming styles of a small
number of old repositories overly affect our analysis.
We performed the Kolmogorov-Smirnov (KS) test to see whether the right tail of ???? in 2018 is generated by a power-law distribution,
a well-known heavy-tailed distribution. The test reported 9 for ???????? and 0.937 for ??-value. The ??-value is greater than the commonly used significance level 0.05. These results of the KS test indicate that it is consistent to assume that the observed values for ?? = 9 are generated by a power-law distribution. Although it is interesting
to discover the generation model of such a distribution, we leave it for future work.
To better understand the trends in method chaining, we manually categorized the method chains in 2018 and 2010 by their behaviors.
For this analysis, we divided the set of method chains into three groups by their length: Short, Long, and ExtLong.
We found 140 chains (50% of ExtLong) in testing code. As mentioned above, all the chains in ExtLong are composed to build an object.
Thus, half of the ExtLong chains build objects for testing.
We found 18 chains (6.43%) using StringBuilder
or StringBuffer in java.lang.

                 RESULT:

This summary was presented our empirical study of method chaining in Java. 
Our analysis quantitatively revealed the widespread and increasing trend of method chaining. 
To provide information for future language/library development, we estimated how effective it
would be to introduce language features and API design for method chaining. 
Although our results support the acceptance of method chaining in the real world, user studies need to be carried out to assert the acceptance. 
It is also interesting and beneficial for a better understanding of method chaining to investigate why real-world programmers prefer (or do not prefer) method chaining. 
The issues mentioned in the StackOverflow thread [8] would be helpful to start such an investigation. 
All of those studies are our primary future work.
